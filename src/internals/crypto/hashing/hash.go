package hashing

import (
	"hash"
	"math/rand"

	"golang.org/x/crypto/sha3"
	"golang.org/x/exp/slices"
)

type HashType int32

const (
	SHA256 HashType = 256
	SHA384 HashType = 384
	SHA512 HashType = 512
)

type HashHandler interface {
	// Hashes message with the given integer key
	Hash(key []byte, message []byte) []byte

	// Compares the message with the other integer hash and integer key
	Compare(message []byte, key, hashValue []byte) bool
}

type Hasher struct {
	internalHasher hash.Hash
}

func CreateNew(hashType HashType) *Hasher {

	var hash hash.Hash

	switch hashType {
	case SHA256:
		hash = sha3.New256()
	case SHA384:
		hash = sha3.New384()
	case SHA512:
		hash = sha3.New512()
	}
	return &Hasher{internalHasher: hash}
}

func (hasher *Hasher) Hash(key []byte, message []byte) []byte {

	// Reset the hasher after the hash value has been created
	defer hasher.internalHasher.Reset()

	// Provide the key and value to be hashed
	hasher.internalHasher.Write(key)
	hasher.internalHasher.Write(message)

	// Get the resulting size of the byte array
	size := hasher.internalHasher.Size()
	resultBytes := hasher.internalHasher.Sum(make([]byte, size))

	return resultBytes
}

func (hasher *Hasher) Compare(message []byte, key, hashValue []byte) bool {

	hashedMessage := hasher.Hash(key, message)

	return slices.Equal(hashValue, hashedMessage) // If the value is zero then it means that they are the same
}

func GenerateRandomByteArray() []byte {

	// We generate a random byte array of 256 bits i.e. 256 / 8 = 32 bytes
	bytes := make([]byte, 32)
	_, err := rand.Read(bytes)

	if err != nil {
		panic("random generated byte array was too short")
	}

	return bytes
}
